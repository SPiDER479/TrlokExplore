BEGIN_OPTIONS
	Workflow "Unlit"
	Alpha "Add"
END_OPTIONS

BEGIN_PROPERTIES
	[HideInInspector] _SGT_WrapSize("", Vector) = (0,0,0,0)
	[HideInInspector] _SGT_FadeData("", Vector) = (0,0,0,0)
	[HideInInspector] _SGT_DataA("", Vector) = (0,0,0,0)
	[HideInInspector] _SGT_DataB("", Vector) = (0,0,0,0)
	[HideInInspector] _SGT_FlickerData("", Vector) = (0,0,0,0)
	[HideInInspector] _SGT_StretchDirection("", Vector) = (0,0,0,0)
	[HideInInspector] _SGT_UnderwaterBrightness("", Float) = 0
	[HideInInspector] _SGT_UnderwaterShadowRange("", Float) = 0
	
	[Header(CLOUDS)]
	[Toggle(_SGT_CLOUDS)] _SGT_Clouds("	Enable", Float) = 0
	[HideInInspector] [NoScaleOffset] _SGT_CloudTex("", 2D) = "black" {}
	[HideInInspector] _SGT_CloudOpacity("", Vector) = (0.0, 0.0, 0.0, 0.0)
	[HideInInspector] _SGT_CloudWarp("", Float) = 0
END_PROPERTIES

BEGIN_DEFINES
	#pragma shader_feature_local _SGT_CLOUDS_OFF _SGT_CLOUDS
END_DEFINES

BEGIN_CBUFFER
	float4   _SGT_WrapSize; // Auto
	float4   _SGT_FadeData; // Auto
	float4   _SGT_DataA; // Auto
	float4   _SGT_DataB; // Auto
	float4   _SGT_FlickerData; // Auto
	float4   _SGT_StretchDirection; // Auto
	float    _SGT_UnderwaterBrightness; // Auto
	float    _SGT_UnderwaterShadowRange; // Auto
	float4x4 _SGT_WorldToLocal; // Auto
	
	// CLOUDS
	sampler2D _SGT_CloudTex;
	float4    _SGT_CloudOpacity;
	float     _SGT_CloudWarp;
	float4x4  _SGT_CloudMatrix;
END_CBUFFER

BEGIN_CODE
	float SGT_SampleCloudDensity(float3 wpos, float bias)
	{
		float3 p = normalize(mul(_SGT_CloudMatrix, float4(wpos, 1.0f)).xyz);
		float2 w = float2(-p.x, p.y);
		float2 z = normalize(w) * pow(length(w), 1.0f / (_SGT_CloudWarp + 1.0f));
		
		return saturate(dot(tex2Dbias(_SGT_CloudTex, float4(z * 0.5f + 0.5f, 0, bias)), _SGT_CloudOpacity));
	}
	
	float SGT_Hash(float seed)
	{
		return frac(sin(dot(float2(seed,seed+1.0), float2(12.9898, 78.233))) * 43758.5453);
	}
	
	float SGT_Noise(float position)
	{
		float i = floor(position);
		float f = frac(position);
		
		float a = SGT_Hash(i);
		float b = SGT_Hash(i + 1.0);
		
		float blend = f * f * (3.0 - 2.0 * f);
		return lerp(a, b, blend);
	}

	void ModifyVertex(inout VertexData v, inout ExtraV2F e)
	{
		float3 wcam = _WorldSpaceCameraPos;
		float  seed = v.texcoord0.w;
		
		#if __SGT_MATRIX
			// Infinite wrap
			float3 wcam_snap = wcam + frac(wcam * _SGT_WrapSize.y) * _SGT_WrapSize.x;
			float4 ocam_snap = SGT_W2O(float4(wcam_snap, 1.0f));
			v.vertex.xyz = frac(v.vertex.xyz - ocam_snap.xyz * _SGT_WrapSize.y + 0.5f) - 0.5f;
			v.vertex.xyz *= _SGT_WrapSize.x;
			
			// Drift
			float  angle1    = seed * 6.2831853f;
			float  angle2    = frac(seed * 0.384759f + _Time.x * 0.17543f) * 6.2831853f;
			float3 direction = float3(cos(angle1) * sin(angle2), cos(angle2), sin(angle1) * sin(angle2));
			float  drift     = _SGT_DataB.y;
			v.vertex.xyz += direction * drift;
			
			// Expand in world space
			float4 ocam = SGT_W2O(float4(wcam, 1.0f));
			float3 view = normalize(ocam.xyz - v.vertex.xyz);
			float3 up   = cross(_SGT_StretchDirection.xyz, view);
			
			v.vertex.xyz += _SGT_StretchDirection.xyz * v.texcoord0.y * _SGT_FadeData.z;
			
			v.vertex.xyz += normalize(up) * v.texcoord0.z * _SGT_FadeData.y;
			
			float flicker = SGT_Noise(seed * 100 + _Time.x * lerp(_SGT_FlickerData.x, _SGT_FlickerData.y, seed));
			
			v.vertexColor.x = lerp(_SGT_FlickerData.z, _SGT_FlickerData.w, flicker);
			
			v.vertexColor.x *= length(up); // Fade out parallel rays
		#endif
	}

	void SurfaceFunction(inout Surface o, inout ShaderData d)
	{
		float4 finalColor       = d.vertexColor.x;
		float  radius           = _SGT_DataB.x;
		float  surfaceSharpness = _SGT_DataA.x;
		float  deepSharpness    = _SGT_DataA.y;
		float  maxDepth         = _SGT_DataB.z;
		
		float camDist = distance(d.worldSpacePosition, _WorldSpaceCameraPos);
		
		float3 localPos = mul(_SGT_WorldToLocal, float4(d.worldSpacePosition, 1.0f)).xyz;
		
		float depth = radius - length(localPos);
		
		finalColor *= saturate(1.0f - camDist * _SGT_FadeData.x);
		
		finalColor *= 1.0f - pow(saturate(1.0f - depth / maxDepth), surfaceSharpness);
		
		finalColor *= 1.0f - pow(saturate(depth / maxDepth), deepSharpness);
		
		finalColor *= 1.0f - pow(saturate(length(d.texcoord0.xy)), 1.0f + 4.0f * d.texcoord0.w);
		
		finalColor *= _SGT_UnderwaterBrightness;
		
		#if _SGT_CLOUDS
			float shadow2 = SGT_SampleCloudDensity(_WorldSpaceCameraPos - d.worldSpaceViewDir * _SGT_UnderwaterShadowRange, 10.0f);
			finalColor.xyz *= 1.0f - shadow2;
		#endif
		
		#if __SGT_OUTPUT
			SGT_OutputWithoutAlpha(o, finalColor);
		#endif
	}
END_CODE